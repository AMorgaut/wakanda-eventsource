var	buffer,	clientPorts,	sse;clientPorts = [];buffer = [];buffer.MAX_AGE = 2 * 60 * 60 * 1000; // 2 hoursbuffer.MAX_EVENTS = 500;buffer.MAX_SIZE = 2 * 1024 * 1024; // 2 Mbbuffer.INCLUDE_COMMENTS = false; // 2 Mbbuffer.size = 0;sse = require("wakanda-eventsource");self.onconnect = function onconnect(msg) {	var		port;	port = msg.ports[0];	port.onmessage = function onmessage(event) {		var			data,			currentIndex,			current;		data = event.data;		switch (data.type) {		case "settings":			// UPDATE EventSource Server settings			if (typeof data.maxAge === 'number') {			    buffer.MAX_AGE = data.bufferMaxAge;			}			if (typeof data.maxAge === 'number') {			    buffer.MAX_EVENTS = data.bufferMaxEvents;			}			if (typeof data.maxAge === 'number') {			    buffer.MAX_SIZE = data.bufferMaxSize;			}			if (typeof data.maxAge === 'boolean') {			    buffer.INCLUDE_COMMENTS = data.bufferIncludeComments;			}			break;		case sse.PUSH:			// MESSAGE PUSHED via ServerSent.prototype.send()			// log to buffer			buffer.push(data);			// manage max age			setTimeout(function () {				buffer.splice(buffer.indexOf(data), 1);				buffer.size -= data.message.length;				data = null;			}, data.id + buffer.MAX_AGE);			buffer.size += data.message.length;			// manage max events and max size			while (buffer.length > buffer.MAX_EVENTS || buffer.size > buffer.MAX_SIZE) {				buffer.size -= buffer[0].message.length;				buffer.splice(1, 1);			}			// push to targets			clientPorts.forEach(function dispatchData(clientConnection, index) {				if (!clientConnection) {					// WORKER CONNECTION LOST					// HTTP CONNECTION CLOSED BY CLIENT ?					clientPorts.splice(index, 1);					return;				}				clientConnection.postMessage({					type: sse.PUSH, 					message: data.message				});			});			break;		case "register":			// HTTP REQUEST HANDLER CONNECTIONS			clientPorts.push(port);			if (typeof data.lastEventId === 'number') {				data.events = [];				currentIndex = buffer.length;				current = buffer[currentIndex];				while (current.id > data.lastEventId) {					data.events.unshift(current.message);					currentIndex -= 1;					current = buffer[currentIndex];				}				if (data.events.length) {					port.postMessage({						type: sse.PUSH, 						message: data.events.join(sse.EOL)					});				}			}			port.postMessage({				type: sse.CONNECTION_READY			});			break;		case "disconnect":			// unused for now			clientPorts.splice(ports.indexOf(port), 1);			port.close();			break;		case sse.STOP:			// service stopped - close all connections			clientPorts.forEach(function dispatchData(clientConnection, index) {				if (!clientConnection) {					// WORKER CONNECTION LOST					// HTTP CONNECTION CLOSED BY CLIENT ?					clientPorts.splice(index, 1);					return;				}				clientConnection.postMessage({					type: sse.STOP				})				clientPorts.splice(index, 1);				clientConnection.close();			});			break;		default:			console.warning('unexpected message', data);		}	};};