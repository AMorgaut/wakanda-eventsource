var	sse;sse = require("wakanda-eventsource");function push(connection, message, nowait) {    // We send the chunk that needs to be send now    connection.sendChunkedData(message);	// For now, we need to release the wait for the response to be sent    exitWait();    if (!nowait) {		// We wait again for the next datas    	wait();	}}function pushComment(connection, comment, nowait) {	push(connection, ': ' + comment + '\n', nowait);}function oneventsourceconnect(httpRequest, httpResponse) {	var		connection,		headers,		accept,		lastEventId,		workerPort;	connection = httpResponse;	headers = connection.headers;	accept = httpRequest.headers.Accept;	if (accept.indexOf('application/json') > -1) {		headers['Content-Type'] = "application/json";		return '{"ok": true}';	}	if (accept.indexOf('text/event-stream') === -1) {		headers['Content-Type'] = "text/plain";		return 'This event source service is active but requires the client to accept "text/event-stream" content type to work';	}	// Specify that we'll send server events	headers['Content-Type'] = "text/event-stream";	headers['Cache-Control'] = 'no-cache';	headers['Connection'] = 'keep-alive';	lastEventId = httpRequest.headers['Last-Event-Id'];	if (lastEventId !== undefined) {		lastEventId = Number(lastEventId);	}	workerPort = new SharedWorker(sse.WORKER_PATH, sse.WORKER_ID).port;	workerPort.onmessage = function onmessage(event) {		var			data;		data = event.data;        switch (data.type) {        case sse.PUSH:	        push(connection, data.message)            break;		case sse.CONNECTION_READY:            // Send a comment - not mandatory - just to make it clear	        pushComment(connection, 'connection ready');			break;		case sse.STOP:			// we can end the HTTP connection	        pushComment(connection, 'event source stop', true);			break;		default:			console.warning('unexpected worker message', data);        }	};	// We register to tell to the SharedWorker to send us the message when it's fired	workerPort.postMessage({		type: "register",		lastEventId: lastEventId	});	// Wait to keep the context alive	wait();}